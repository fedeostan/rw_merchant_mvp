/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * Merchant Crypto Wallet Dashboard API
 * MVP API contract for merchant crypto wallet dashboard

## Authentication
This API uses Supabase Auth for authentication. Users authenticate via OTP (One-Time Password)
sent to their email. The authentication flow is handled directly by Supabase Auth client,
not through these API endpoints.

For protected endpoints, include the Supabase session access token in the Authorization header:
`Authorization: Bearer <supabase_access_token>`

 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  ApiKeyResponse,
  ApiKeysResponse,
  AuthResponse,
  CreateModuleRequest,
  GetOrgsOrgIdTransactionsParams,
  MeResponse,
  Module,
  MoneyBalance,
  PostAuthOtpSendBody,
  PostAuthOtpVerifyBody,
  PostOrgsOrgIdApikeysBody,
  PostWalletBuy201,
  PostWalletBuyBody,
  PostWalletReceive200,
  PostWalletReceiveBody,
  PostWalletSell201,
  PostWalletSell400,
  PostWalletSellBody,
  PostWalletSend201,
  PostWalletSend400,
  PostWalletSendBody,
  TransactionsResponse,
  UpdateModuleRequest,
} from ".././generated/schemas";

import { customInstance } from ".././fetcher";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * **DEPRECATED:** This endpoint is no longer used. Authentication is now handled
directly by Supabase Auth client using `supabase.auth.signInWithOtp()`.

 * @deprecated
 * @summary Send OTP to email (DEPRECATED)
 */
export const postAuthOtpSend = (
  postAuthOtpSendBody: PostAuthOtpSendBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<void>(
    {
      url: `/auth/otp/send`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postAuthOtpSendBody,
      signal,
    },
    options
  );
};

export const getPostAuthOtpSendMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthOtpSend>>,
    TError,
    { data: PostAuthOtpSendBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthOtpSend>>,
  TError,
  { data: PostAuthOtpSendBody },
  TContext
> => {
  const mutationKey = ["postAuthOtpSend"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthOtpSend>>,
    { data: PostAuthOtpSendBody }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthOtpSend(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthOtpSendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthOtpSend>>
>;
export type PostAuthOtpSendMutationBody = PostAuthOtpSendBody;
export type PostAuthOtpSendMutationError = unknown;

/**
 * @deprecated
 * @summary Send OTP to email (DEPRECATED)
 */
export const usePostAuthOtpSend = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthOtpSend>>,
      TError,
      { data: PostAuthOtpSendBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthOtpSend>>,
  TError,
  { data: PostAuthOtpSendBody },
  TContext
> => {
  const mutationOptions = getPostAuthOtpSendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * **DEPRECATED:** This endpoint is no longer used. OTP verification is now handled
directly by Supabase Auth client using `supabase.auth.verifyOtp()`.

 * @deprecated
 * @summary Verify OTP and authenticate (DEPRECATED)
 */
export const postAuthOtpVerify = (
  postAuthOtpVerifyBody: PostAuthOtpVerifyBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<AuthResponse>(
    {
      url: `/auth/otp/verify`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postAuthOtpVerifyBody,
      signal,
    },
    options
  );
};

export const getPostAuthOtpVerifyMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthOtpVerify>>,
    TError,
    { data: PostAuthOtpVerifyBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAuthOtpVerify>>,
  TError,
  { data: PostAuthOtpVerifyBody },
  TContext
> => {
  const mutationKey = ["postAuthOtpVerify"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthOtpVerify>>,
    { data: PostAuthOtpVerifyBody }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthOtpVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthOtpVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthOtpVerify>>
>;
export type PostAuthOtpVerifyMutationBody = PostAuthOtpVerifyBody;
export type PostAuthOtpVerifyMutationError = unknown;

/**
 * @deprecated
 * @summary Verify OTP and authenticate (DEPRECATED)
 */
export const usePostAuthOtpVerify = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAuthOtpVerify>>,
      TError,
      { data: PostAuthOtpVerifyBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postAuthOtpVerify>>,
  TError,
  { data: PostAuthOtpVerifyBody },
  TContext
> => {
  const mutationOptions = getPostAuthOtpVerifyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get current user and org
 */
export const getMe = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MeResponse>(
    { url: `/me`, method: "GET", signal },
    options
  );
};

export const getGetMeQueryKey = () => {
  return [`/me`] as const;
};

export const getGetMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMeQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMe>>> = ({
    signal,
  }) => getMe(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMeQueryResult = NonNullable<Awaited<ReturnType<typeof getMe>>>;
export type GetMeQueryError = unknown;

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMe>>,
          TError,
          Awaited<ReturnType<typeof getMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get current user and org
 */

export function useGetMe<
  TData = Awaited<ReturnType<typeof getMe>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMeQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Calculate organization balance from all transactions.
Available balance = SUM(amount WHERE type='in' AND status='posted') - SUM(amount WHERE type='out' AND status='posted')
Pending balance = SUM(amount WHERE type='in' AND status='pending') - SUM(amount WHERE type='out' AND status='pending')

 * @summary Get balance for organization
 */
export const getOrgsOrgIdBalance = (
  orgId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<MoneyBalance>(
    { url: `/orgs/${orgId}/balance`, method: "GET", signal },
    options
  );
};

export const getGetOrgsOrgIdBalanceQueryKey = (orgId?: string) => {
  return [`/orgs/${orgId}/balance`] as const;
};

export const getGetOrgsOrgIdBalanceQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetOrgsOrgIdBalanceQueryKey(orgId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOrgsOrgIdBalance>>
  > = ({ signal }) => getOrgsOrgIdBalance(orgId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!orgId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrgsOrgIdBalanceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrgsOrgIdBalance>>
>;
export type GetOrgsOrgIdBalanceQueryError = unknown;

export function useGetOrgsOrgIdBalance<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
  TError = unknown,
>(
  orgId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdBalance>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdBalance<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdBalance>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdBalance<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get balance for organization
 */

export function useGetOrgsOrgIdBalance<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdBalance>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOrgsOrgIdBalanceQueryOptions(orgId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List transactions with pagination
 */
export const getOrgsOrgIdTransactions = (
  orgId: string,
  params?: GetOrgsOrgIdTransactionsParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<TransactionsResponse>(
    { url: `/orgs/${orgId}/transactions`, method: "GET", params, signal },
    options
  );
};

export const getGetOrgsOrgIdTransactionsQueryKey = (
  orgId?: string,
  params?: GetOrgsOrgIdTransactionsParams
) => {
  return [`/orgs/${orgId}/transactions`, ...(params ? [params] : [])] as const;
};

export const getGetOrgsOrgIdTransactionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
  TError = unknown,
>(
  orgId: string,
  params?: GetOrgsOrgIdTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetOrgsOrgIdTransactionsQueryKey(orgId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>
  > = ({ signal }) =>
    getOrgsOrgIdTransactions(orgId, params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!orgId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrgsOrgIdTransactionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>
>;
export type GetOrgsOrgIdTransactionsQueryError = unknown;

export function useGetOrgsOrgIdTransactions<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
  TError = unknown,
>(
  orgId: string,
  params: undefined | GetOrgsOrgIdTransactionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdTransactions<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
  TError = unknown,
>(
  orgId: string,
  params?: GetOrgsOrgIdTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdTransactions<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
  TError = unknown,
>(
  orgId: string,
  params?: GetOrgsOrgIdTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List transactions with pagination
 */

export function useGetOrgsOrgIdTransactions<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
  TError = unknown,
>(
  orgId: string,
  params?: GetOrgsOrgIdTransactionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdTransactions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOrgsOrgIdTransactionsQueryOptions(
    orgId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary List modules for org
 */
export const getOrgsOrgIdModules = (
  orgId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Module[]>(
    { url: `/orgs/${orgId}/modules`, method: "GET", signal },
    options
  );
};

export const getGetOrgsOrgIdModulesQueryKey = (orgId?: string) => {
  return [`/orgs/${orgId}/modules`] as const;
};

export const getGetOrgsOrgIdModulesQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetOrgsOrgIdModulesQueryKey(orgId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOrgsOrgIdModules>>
  > = ({ signal }) => getOrgsOrgIdModules(orgId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!orgId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrgsOrgIdModulesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrgsOrgIdModules>>
>;
export type GetOrgsOrgIdModulesQueryError = unknown;

export function useGetOrgsOrgIdModules<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
  TError = unknown,
>(
  orgId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdModules>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdModules<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdModules>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdModules<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List modules for org
 */

export function useGetOrgsOrgIdModules<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModules>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOrgsOrgIdModulesQueryOptions(orgId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new module
 */
export const postOrgsOrgIdModules = (
  orgId: string,
  createModuleRequest: CreateModuleRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Module>(
    {
      url: `/orgs/${orgId}/modules`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createModuleRequest,
      signal,
    },
    options
  );
};

export const getPostOrgsOrgIdModulesMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postOrgsOrgIdModules>>,
    TError,
    { orgId: string; data: CreateModuleRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postOrgsOrgIdModules>>,
  TError,
  { orgId: string; data: CreateModuleRequest },
  TContext
> => {
  const mutationKey = ["postOrgsOrgIdModules"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postOrgsOrgIdModules>>,
    { orgId: string; data: CreateModuleRequest }
  > = (props) => {
    const { orgId, data } = props ?? {};

    return postOrgsOrgIdModules(orgId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostOrgsOrgIdModulesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postOrgsOrgIdModules>>
>;
export type PostOrgsOrgIdModulesMutationBody = CreateModuleRequest;
export type PostOrgsOrgIdModulesMutationError = unknown;

/**
 * @summary Create a new module
 */
export const usePostOrgsOrgIdModules = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postOrgsOrgIdModules>>,
      TError,
      { orgId: string; data: CreateModuleRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postOrgsOrgIdModules>>,
  TError,
  { orgId: string; data: CreateModuleRequest },
  TContext
> => {
  const mutationOptions = getPostOrgsOrgIdModulesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get a single module
 */
export const getOrgsOrgIdModulesModuleId = (
  orgId: string,
  moduleId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<Module>(
    { url: `/orgs/${orgId}/modules/${moduleId}`, method: "GET", signal },
    options
  );
};

export const getGetOrgsOrgIdModulesModuleIdQueryKey = (
  orgId?: string,
  moduleId?: string
) => {
  return [`/orgs/${orgId}/modules/${moduleId}`] as const;
};

export const getGetOrgsOrgIdModulesModuleIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
  TError = void,
>(
  orgId: string,
  moduleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetOrgsOrgIdModulesModuleIdQueryKey(orgId, moduleId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>
  > = ({ signal }) =>
    getOrgsOrgIdModulesModuleId(orgId, moduleId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(orgId && moduleId),
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrgsOrgIdModulesModuleIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>
>;
export type GetOrgsOrgIdModulesModuleIdQueryError = void;

export function useGetOrgsOrgIdModulesModuleId<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
  TError = void,
>(
  orgId: string,
  moduleId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdModulesModuleId<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
  TError = void,
>(
  orgId: string,
  moduleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdModulesModuleId<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
  TError = void,
>(
  orgId: string,
  moduleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a single module
 */

export function useGetOrgsOrgIdModulesModuleId<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
  TError = void,
>(
  orgId: string,
  moduleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdModulesModuleId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOrgsOrgIdModulesModuleIdQueryOptions(
    orgId,
    moduleId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Update a module
 */
export const patchOrgsOrgIdModulesModuleId = (
  orgId: string,
  moduleId: string,
  updateModuleRequest: UpdateModuleRequest,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<Module>(
    {
      url: `/orgs/${orgId}/modules/${moduleId}`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateModuleRequest,
    },
    options
  );
};

export const getPatchOrgsOrgIdModulesModuleIdMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>,
    TError,
    { orgId: string; moduleId: string; data: UpdateModuleRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>,
  TError,
  { orgId: string; moduleId: string; data: UpdateModuleRequest },
  TContext
> => {
  const mutationKey = ["patchOrgsOrgIdModulesModuleId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>,
    { orgId: string; moduleId: string; data: UpdateModuleRequest }
  > = (props) => {
    const { orgId, moduleId, data } = props ?? {};

    return patchOrgsOrgIdModulesModuleId(orgId, moduleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchOrgsOrgIdModulesModuleIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>
>;
export type PatchOrgsOrgIdModulesModuleIdMutationBody = UpdateModuleRequest;
export type PatchOrgsOrgIdModulesModuleIdMutationError = void;

/**
 * @summary Update a module
 */
export const usePatchOrgsOrgIdModulesModuleId = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>,
      TError,
      { orgId: string; moduleId: string; data: UpdateModuleRequest },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof patchOrgsOrgIdModulesModuleId>>,
  TError,
  { orgId: string; moduleId: string; data: UpdateModuleRequest },
  TContext
> => {
  const mutationOptions =
    getPatchOrgsOrgIdModulesModuleIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete a module
 */
export const deleteOrgsOrgIdModulesModuleId = (
  orgId: string,
  moduleId: string,
  options?: SecondParameter<typeof customInstance>
) => {
  return customInstance<void>(
    { url: `/orgs/${orgId}/modules/${moduleId}`, method: "DELETE" },
    options
  );
};

export const getDeleteOrgsOrgIdModulesModuleIdMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>,
    TError,
    { orgId: string; moduleId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>,
  TError,
  { orgId: string; moduleId: string },
  TContext
> => {
  const mutationKey = ["deleteOrgsOrgIdModulesModuleId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>,
    { orgId: string; moduleId: string }
  > = (props) => {
    const { orgId, moduleId } = props ?? {};

    return deleteOrgsOrgIdModulesModuleId(orgId, moduleId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteOrgsOrgIdModulesModuleIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>
>;

export type DeleteOrgsOrgIdModulesModuleIdMutationError = void;

/**
 * @summary Delete a module
 */
export const useDeleteOrgsOrgIdModulesModuleId = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>,
      TError,
      { orgId: string; moduleId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteOrgsOrgIdModulesModuleId>>,
  TError,
  { orgId: string; moduleId: string },
  TContext
> => {
  const mutationOptions =
    getDeleteOrgsOrgIdModulesModuleIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary List API keys for org
 */
export const getOrgsOrgIdApikeys = (
  orgId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ApiKeysResponse>(
    { url: `/orgs/${orgId}/apikeys`, method: "GET", signal },
    options
  );
};

export const getGetOrgsOrgIdApikeysQueryKey = (orgId?: string) => {
  return [`/orgs/${orgId}/apikeys`] as const;
};

export const getGetOrgsOrgIdApikeysQueryOptions = <
  TData = Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetOrgsOrgIdApikeysQueryKey(orgId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>
  > = ({ signal }) => getOrgsOrgIdApikeys(orgId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!orgId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOrgsOrgIdApikeysQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>
>;
export type GetOrgsOrgIdApikeysQueryError = unknown;

export function useGetOrgsOrgIdApikeys<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
  TError = unknown,
>(
  orgId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdApikeys<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
          TError,
          Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetOrgsOrgIdApikeys<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List API keys for org
 */

export function useGetOrgsOrgIdApikeys<
  TData = Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
  TError = unknown,
>(
  orgId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOrgsOrgIdApikeys>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetOrgsOrgIdApikeysQueryOptions(orgId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Create a new API key
 */
export const postOrgsOrgIdApikeys = (
  orgId: string,
  postOrgsOrgIdApikeysBody?: PostOrgsOrgIdApikeysBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<ApiKeyResponse>(
    {
      url: `/orgs/${orgId}/apikeys`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postOrgsOrgIdApikeysBody,
      signal,
    },
    options
  );
};

export const getPostOrgsOrgIdApikeysMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>,
    TError,
    { orgId: string; data: PostOrgsOrgIdApikeysBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>,
  TError,
  { orgId: string; data: PostOrgsOrgIdApikeysBody },
  TContext
> => {
  const mutationKey = ["postOrgsOrgIdApikeys"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>,
    { orgId: string; data: PostOrgsOrgIdApikeysBody }
  > = (props) => {
    const { orgId, data } = props ?? {};

    return postOrgsOrgIdApikeys(orgId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostOrgsOrgIdApikeysMutationResult = NonNullable<
  Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>
>;
export type PostOrgsOrgIdApikeysMutationBody = PostOrgsOrgIdApikeysBody;
export type PostOrgsOrgIdApikeysMutationError = unknown;

/**
 * @summary Create a new API key
 */
export const usePostOrgsOrgIdApikeys = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>,
      TError,
      { orgId: string; data: PostOrgsOrgIdApikeysBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postOrgsOrgIdApikeys>>,
  TError,
  { orgId: string; data: PostOrgsOrgIdApikeysBody },
  TContext
> => {
  const mutationOptions = getPostOrgsOrgIdApikeysMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create an incoming transaction for buying MNEE with a payment method.
This will:
- Create a transaction with type='in', method='card', display_type='buy', status='posted'
- Assign to default "Wallet" module (creates if doesn't exist)
- Generate realistic mock blockchain hash (tx_hash_in)
- Return real transaction ID and full transaction details

 * @summary Buy MNEE and create transaction
 */
export const postWalletBuy = (
  postWalletBuyBody: PostWalletBuyBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PostWalletBuy201>(
    {
      url: `/wallet/buy`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postWalletBuyBody,
      signal,
    },
    options
  );
};

export const getPostWalletBuyMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWalletBuy>>,
    TError,
    { data: PostWalletBuyBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postWalletBuy>>,
  TError,
  { data: PostWalletBuyBody },
  TContext
> => {
  const mutationKey = ["postWalletBuy"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postWalletBuy>>,
    { data: PostWalletBuyBody }
  > = (props) => {
    const { data } = props ?? {};

    return postWalletBuy(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostWalletBuyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postWalletBuy>>
>;
export type PostWalletBuyMutationBody = PostWalletBuyBody;
export type PostWalletBuyMutationError = void;

/**
 * @summary Buy MNEE and create transaction
 */
export const usePostWalletBuy = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postWalletBuy>>,
      TError,
      { data: PostWalletBuyBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postWalletBuy>>,
  TError,
  { data: PostWalletBuyBody },
  TContext
> => {
  const mutationOptions = getPostWalletBuyMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create an outgoing transaction for selling MNEE to bank account.
This will:
- **Validate sufficient balance** before allowing the transaction
- Create a transaction with type='out', method='bank', display_type='sell', status='posted'
- Assign to default "Wallet" module
- Return real transaction ID and full transaction details

 * @summary Sell MNEE and create transaction
 */
export const postWalletSell = (
  postWalletSellBody: PostWalletSellBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PostWalletSell201>(
    {
      url: `/wallet/sell`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postWalletSellBody,
      signal,
    },
    options
  );
};

export const getPostWalletSellMutationOptions = <
  TError = PostWalletSell400 | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWalletSell>>,
    TError,
    { data: PostWalletSellBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postWalletSell>>,
  TError,
  { data: PostWalletSellBody },
  TContext
> => {
  const mutationKey = ["postWalletSell"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postWalletSell>>,
    { data: PostWalletSellBody }
  > = (props) => {
    const { data } = props ?? {};

    return postWalletSell(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostWalletSellMutationResult = NonNullable<
  Awaited<ReturnType<typeof postWalletSell>>
>;
export type PostWalletSellMutationBody = PostWalletSellBody;
export type PostWalletSellMutationError = PostWalletSell400 | void;

/**
 * @summary Sell MNEE and create transaction
 */
export const usePostWalletSell = <
  TError = PostWalletSell400 | void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postWalletSell>>,
      TError,
      { data: PostWalletSellBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postWalletSell>>,
  TError,
  { data: PostWalletSellBody },
  TContext
> => {
  const mutationOptions = getPostWalletSellMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Create an outgoing transaction for sending MNEE to another wallet address.
This will:
- **Validate sufficient balance** before allowing the transaction
- Create a transaction with type='out', method='transfer', display_type='send', status='posted'
- Store recipient address in customer_address field
- Generate mock blockchain transaction hash (send_hash)
- Assign to default "Wallet" module
- Return real transaction ID, transaction details, and mock blockchain hash

 * @summary Send MNEE to another wallet
 */
export const postWalletSend = (
  postWalletSendBody: PostWalletSendBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PostWalletSend201>(
    {
      url: `/wallet/send`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postWalletSendBody,
      signal,
    },
    options
  );
};

export const getPostWalletSendMutationOptions = <
  TError = PostWalletSend400 | void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWalletSend>>,
    TError,
    { data: PostWalletSendBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postWalletSend>>,
  TError,
  { data: PostWalletSendBody },
  TContext
> => {
  const mutationKey = ["postWalletSend"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postWalletSend>>,
    { data: PostWalletSendBody }
  > = (props) => {
    const { data } = props ?? {};

    return postWalletSend(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostWalletSendMutationResult = NonNullable<
  Awaited<ReturnType<typeof postWalletSend>>
>;
export type PostWalletSendMutationBody = PostWalletSendBody;
export type PostWalletSendMutationError = PostWalletSend400 | void;

/**
 * @summary Send MNEE to another wallet
 */
export const usePostWalletSend = <
  TError = PostWalletSend400 | void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postWalletSend>>,
      TError,
      { data: PostWalletSendBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postWalletSend>>,
  TError,
  { data: PostWalletSendBody },
  TContext
> => {
  const mutationOptions = getPostWalletSendMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Generate a mock wallet address and QR code for receiving MNEE.
This will:
- Generate mock Ethereum wallet address (0x + 40 hex characters)
- Generate QR code as base64 data URL using the address
- If amount is provided, encode it in the QR code for payment request
- **Does NOT create a transaction** (transaction created when funds are actually received)
- Return wallet address and QR code data

 * @summary Generate wallet address and QR code for receiving MNEE
 */
export const postWalletReceive = (
  postWalletReceiveBody?: PostWalletReceiveBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal
) => {
  return customInstance<PostWalletReceive200>(
    {
      url: `/wallet/receive`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: postWalletReceiveBody,
      signal,
    },
    options
  );
};

export const getPostWalletReceiveMutationOptions = <
  TError = void,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postWalletReceive>>,
    TError,
    { data: PostWalletReceiveBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postWalletReceive>>,
  TError,
  { data: PostWalletReceiveBody },
  TContext
> => {
  const mutationKey = ["postWalletReceive"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postWalletReceive>>,
    { data: PostWalletReceiveBody }
  > = (props) => {
    const { data } = props ?? {};

    return postWalletReceive(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostWalletReceiveMutationResult = NonNullable<
  Awaited<ReturnType<typeof postWalletReceive>>
>;
export type PostWalletReceiveMutationBody = PostWalletReceiveBody;
export type PostWalletReceiveMutationError = void;

/**
 * @summary Generate wallet address and QR code for receiving MNEE
 */
export const usePostWalletReceive = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postWalletReceive>>,
      TError,
      { data: PostWalletReceiveBody },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof postWalletReceive>>,
  TError,
  { data: PostWalletReceiveBody },
  TContext
> => {
  const mutationOptions = getPostWalletReceiveMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
